# Формат импорта карточек LingoCard

## Поддерживаемые контейнеры

Импорт принимает два варианта JSON:

1. **Упрощённый контейнер**

```json
{
  "cards": [
    {
      "id": "...",
      "inf": "machen",
      "tr_1_ru": "делать"
    }
  ]
}
```

2. **Полный экспорт LingoCard** (с метаданными)

```json
{
  "version": 1,
  "kind": "lingocard",
  "passport": {
    "source": "LingoCard"
  },
  "card": {
    "widthMm": 150,
    "heightMm": 105
  },
  "cards": [
    {
      "id": "...",
      "inf": "machen",
      "tr_1_ru": "делать",
      "boxes": []
    }
  ]
}
```

Также допустим **прямой массив карточек**:

```json
[
  {
    "id": "...",
    "inf": "machen",
    "tr_1_ru": "делать"
  }
]
```

## Минимальная структура карточки

Минимально для карточки нужны:

- `id` — строка
- `inf` — строка (инфинитив)

Остальные поля опциональны и будут заполнены значениями по умолчанию:

- `tr_1_ru`, `tr_2_ru`, `forms_p3` и др.
- `freq` (1–5)
- `tags` (массив строк)
- `boxes` (массив блоков, если есть в файле)

## Блоки `boxes`: что валидно и как рендерится

Поддерживаются блоки с полями геометрии (`xMm`, `yMm`, `wMm`, `hMm`) и текстовыми атрибутами (`text`, `staticText`, `textMode`, `label`).

Если у блока отсутствуют часть полей (`style`, `fieldId`, `fontPt` и т.д.), импорт не отбрасывает блок:

- недостающие поля нормализуются значениями по умолчанию,
- неизвестные типы блоков рендерятся как обычные текстовые блоки,
- блоки отображаются на холсте **как есть** (без фильтра по «известным id»).



Если `boxes` в карточке отсутствует или пустой массив, превью автоматически строит читабельный fallback-макет из всех непустых полей карточки (переводы, формы, синонимы, примеры, рекции) в фиксированном порядке. Это гарантирует, что даже при импорте сотен карточек без явной геометрии данные будут отображаться последовательно, а не «двумя случайными блоками».

Все импортированные/сгенерированные блоки ограничиваются границами карточки и не могут выходить за пределы превью.

## Частые ошибки

- **Нет ключа `cards`** — файл не распознан как формат карточек.
- **`cards` не массив** — нужно, чтобы `cards` был именно массивом объектов.
- **Сломанный JSON** — сначала проверьте валидность JSON.

## Примеры

- `samples/cards.valid.min.json` — минимальный валидный пример.
- `samples/cards.valid.full.json` — полный пример с заполненными полями.

## Автоматическая компоновка (semantic layout)

Кнопка **«Авто-компоновка всех»** в колонке данных пересчитывает `boxes` для всех карточек выбранной коллекции по семантической модели:

- Hero: `inf` (крупный шрифт, верх карточки)
- Meta: `freq` + `tags`
- Core meanings: `tr_*`
- Grammar: `forms_*`
- Examples / Rektion: `ex_*`, `rek_*`

Правила:

- генерация детерминированная (одни и те же данные => одинаковый layout),
- все блоки создаются внутри границ карточки,
- параметры зависят от размеров карточки (мм), поэтому превью и PDF остаются согласованными по физике.


### Правила шаблонной авто-компоновки

`Авто-компоновка всех` использует детерминированный шаблон зон в мм:

- Hero (`inf`) и Meta (`freq + tags`) сверху,
- левая колонка: Переводы + Примеры,
- правая колонка: Формы + Синонимы + Рекомендации.

Для каждой зоны применяется `fitTextToBox`: размер шрифта подбирается в диапазоне `5..36 pt`, затем при переполнении ограничиваются строки с аккуратным `…`.
Это гарантирует: одинаковый входной JSON даёт одинаковую геометрию блоков и стабильный результат после перезапуска.
